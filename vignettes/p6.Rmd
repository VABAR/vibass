---
title: 'Practical 6: Software and GLMs'
author: "VIBASS"
output:
  html_vignette:
    fig_caption: yes
    number_sections: yes
    toc: yes
    fig_width: 6
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{Practical 6: Software and GLMs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

# Software for Bayesian Statistical Analysis

So far, simple Bayesian models with conjugate priors have been
considered.  As explained in previous practicals, when the posterior
distribution is not available in closed form, MCMC algorithms such as the
Metropolis-Hastings or
Gibbs Sampling can be used to obtain samples from it.

In general, posterior distributions are seldom available in closed form and
implementing MCMC algorithms for complex models can be technically difficult
and very time-consuming.

For this reason, in this Practical we start by listing a number of `R`
packages to fit Bayesian statistical models. These packages equip researchers
with tools for dealing with complex models efficiently,
without having to do a lot of extra mathematics and coding. Fitting Bayesian
models in `R` is then much like fitting non-Bayesian models, using
model-fitting functions at the command line, and using standard syntax for
model specification.

## Specific Software

* We have already seen package `MCMCpack` in R, which contains functions
such as `MCMClogit()`, `MCMCPoisson()` and `MCMCprobit()` for fitting
specific kinds of models via simple function calls.
* `BayesX` (http://www.bayesx.org/) implements MCMC methods to obtain samples
from the joint posterior and is conveniently accessed from R via the package
`R2BayesX`. It has a very simple interface to define models.
using a `formula` (in the same way as with `glm()` and `gam()` functions).
* `INLA` (https://www.r-inla.org/) is based on producing (accurate)
approximations to the marginal posterior distributions of the model parameters.
Although this can be enough most of the time, making multivariate inference
with `INLA` can be difficult or impossible. However, in many cases this is
not needed and `INLA` can fit some classes of models in a fraction of the
time it takes with MCMC.  It has a very simple interface to define models,
although it cannot be installed directly from CRAN - instead you have a
specific website where it can be downloaded:
[https://www.r-inla.org/download-install](https://www.r-inla.org/download-install)
* A classic MCMC program is `BUGS`, (Bayesian Analysis using Gibbs Sampling)
described in Lunn et al. (2000):
[http://www.mrc-bsu.cam.ac.uk/bugs/winbugs/contents.shtml](http://www.mrc-bsu.cam.ac.uk/bugs/winbugs/contents.shtml).
`BUGS` can be used through graphical interfaces `WinBUGS` and `OpenBUGS`. Both of
these packages can be called from within R using packages `R2WinBUGS` and
`R2OpenBUGS`. There also exists software called
[`multibugs`](https://www.multibugs.org/) which is a parallel implementation of
BUGS.
* `JAGS`, which stands for “just another Gibbs sampler”. Can also be called from
R using package `r2jags`.
* The `NIMBLE` package extends `BUGS` and implements MCMC and other methods
for Bayesian inference. You can get it from
[https://r-nimble.org](https://r-nimble.org), and is best
run directly from R.
* The `Stan` software implements Hamiltonian Monte Carlo and other methods for
fitting hierarchical Bayesian models. It is available from
[https://mc-stan.org](https://mc-stan.org).

# Bayesian Logistic Regression

## Model Formulation

To summarise the model formulation presented in the lecture, given a response
variable $Y_i$ representing the count of a number of successes from a given
number of trials $n_i$ with success probability $\theta_i$, we have

* $(Y_i \mid \boldsymbol \theta_i) \sim\mbox{Bi}(n_i, \theta_i),\,\, i.i.d.\,\,, i=1, \ldots, m$
\begin{align*}
 \mbox{logit}(\theta_i) & =\eta_i \nonumber\\
\eta_{i} & =\beta_0+\beta_1 x_{i1}+\ldots+\beta_p x_{ip}=\boldsymbol x_i\boldsymbol \beta\nonumber
\end{align*}
assuming the logit link function and with linear predictor $\eta_{i}$.

## Example: Fake News

The `fake_news` data set in the `bayesrules` package in `R` contains
information about 150 news articles, some real news and some fake news.

In this example, we will look at trying to predict whether an article of news
is fake or not given three explanatory variables.

We can use the following code to extract the variables we want from the
data set:

```{r}
library(bayesrules)
fakenews <- fake_news[,c("type","title_has_excl","title_words","negative")]
```

The response variable `type` takes values `fake` or `real`, which should be
self-explanatory. The three explanatory variables are:

* `title_has_excl`, whether or not the article contains an excalamation mark (values `TRUE` or `FALSE`);

* `title_words`, the number of words in the title (a positive integer); and

* `negative`, a sentiment rating, recorded on a continuous scale.

In the exercise to follow, we will examine whether the chance of an article
being fake news is related to the three covariates here.

## Fitting Bayesian Logistic Regression Models

We will analyse these data using the `MCMClogit()` function in package
`MCMCpack`. Note that this function uses a Metropolis-Hastings algorithm to
fit the model, rather than the Gibbs Sampler as used by `MCMCregress()`.

The package must first be loaded into R:
```{r}
library(MCMCpack)
```

The syntax for fitting a Bayesian Logistic Regression Model with one response
variable and three explanatory variables will be like so:

```{r eval=FALSE}
model1 <- MCMClogit(formula = y ~ x1 + x2 + x3,
                 data = data.set)
```
with extra options for burn-in (`burnin`), MCMC samples (`mcmc`), and thinning
(`thin`) as with `MCMCregress()`.

## Model Fitting

Note that the variable `title_has_excl` will need to be either replaced by or
converted to a factor, for example

```{r}
fakenews$titlehasexcl <- as.factor(fakenews$title_has_excl)
```

Function `summary` produces a summary (including parameter
estimates etc) for the parameters.

<!-- In order to be able to obtain output plots from BayesX, it seems that we need -->
<!-- to create a new version of the response variable of type logical: -->

```{r}
fakenews$typeFAKE <- fakenews$type == "fake"
```

## Exercises

* Perform an exploratory assessment of the fake news data set, in particular
looking at the possible relationships between the explanatory variables
and the fake/real response variable `typeFAKE`. You may wish to use the R 
function `boxplot()` here.

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Is there a link between the fakeness and whether the title has an exclamation mark?
    table(fakenews$title_has_excl, fakenews$type)
    # For the quantitative variables, look at boxplots on fake vs real
    boxplot(fakenews$title_words ~ fakenews$type)
    boxplot(fakenews$negative ~ fakenews$type)

    ```
    
    </details>
    
* Fit a Bayesian model in MCMCpack using the fake news `typeFAKE` variable as
response and the others as covariates. Examine the output; does the model fit
well, and is there any evidence that any of the explanatory variables are
associated with changes in probability of an article being fake or not?

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Fit the logistic regression model
    results1 <- MCMClogit(formula = typeFAKE ~ titlehasexcl + title_words + negative,
    data = fakenews,
    burnin = 5000, mcmc = 15000, thin=1,
    beta.start = NA, # uses maximum likelihood estimates as starting values
    b0 = c(0,0,0,0), B0 = c(0.0001,0.0001,0.0001,0.0001),
    verbose=1000)
    summary(results1)
    ```
    
    </details>

* Produce plots of the MCMC sample traces and the estimated posterior
distributions for the model parameters. Does it seem like convergence has been
achieved?

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE, fig.width = 5, fig.height = 10}
    # Trace plots
    par(mfrow=c(2,2))
    traceplot(results1)
    ```

    ```{r fig = TRUE} 
    # And the density plots
    par(mfrow=c(2,2))
    densplot(results1)

    ```
    
    </details>

* Fit a non-Bayesian model using `glm()` for comparison. How do the model fits
compare?
    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Fit model - note similarity with bayesx syntax
    glm.output <- glm(formula = typeFAKE ~ titlehasexcl + title_words + negative,
      data = fakenews,
      family = "binomial")
    # Summarise output
    summary(glm.output)
    # Perform ANOVA on each variable in turn
    drop1(glm.output,test="Chisq")
    ```
    
    </details>
    
# Bayesian Poisson Regression

## Model Formulation

To summarise the model formulation presented in the lecture, given a response
variable $Y_i$ representing the counts occurring from a process with mean 
parameter $\lambda_i$:

* $(Y_i \mid \boldsymbol \lambda_i) \sim\mbox{Po}(\lambda_i),\,\, i.i.d.\,\,, i=1, \ldots, n$
\begin{align*}
 \mbox{log}(\lambda_i) & =\eta_i \nonumber\\
\eta_{i} & =\beta_0+\beta_1 x_{i1}+\ldots+\beta_p x_{ip}=\boldsymbol x_i\boldsymbol \beta\nonumber
\end{align*}
assuming the log link function and with linear predictor $\eta_{i}$.

## Example: Emergency Room Complaints

For this example we will use the `esdcomp` data set, which is available in the
`faraway` package. This data set records complaints about emergency room
doctors.  In particular, data was recorded on 44 doctors working in an
emergency service at a hospital to study the factors affecting the number of
complaints received.

The response variable that we will use is `complaints`, an integer count of the
number of complaints received. It is expected that the number of complaints will
scale by the number of visits (contained in the `visits` column), so we are
modelling the **rate** of complaints per visit - thus we will need to include
a new variable `log.visits` as an offset.

The three explanatory variables we will use in the analysis are:

* `residency`, whether or not the doctor is still in residency training (values
`N` or `Y`);

* `gender`, the gender of the doctor (values `F` or `M`); and

* `revenue`, dollars per hour earned by the doctor, recorded as an integer.

Our simple aim here is to assess whether the seniority, gender or income of the
doctor is linked with the rate of complaints against that doctor.

We can use the following code to extract the data we want without having to load
the whole package:

```{r}
esdcomp <- faraway::esdcomp    
```

## Fitting Bayesian Poisson Regression Models

Again we can use package `MCMCpack` to fit this form of Bayesian generalised
linear model, this time using the function `MCMCpoisson()`.

If not loaded already, the package must be loaded into R:
```{r echo=FALSE}
library(MCMCpack)
```

The syntax for fitting a Bayesian Poisson Regression Model with one
response variable, three explanatory variables and an offset `w` would be
like so:
```{r eval=FALSE}
results2 <- MCMCpoisson(formula = y~x1+x2+x3+w,
                 data = data.set)
```
but we will to be careful with the prior for `w`, as noted below.

For a Poisson GLM we will be using a log() link function by default, so for the
offset we must compute the log of the number of visits and include that in
the data set `esdcomp`:

```{r}
esdcomp$log.visits <- log(esdcomp$visits)    
```

Using an offset term in a model fitted by (non-Bayesian) `glm` in R is simpler;
we just by add

`offset(log.visits)`

in the model formula when calling `glm` (see later). However, `MCMCpoisson`
does not allow offset terms, but there is a workaround. An offset term is
essentially just a covariate in a model with coefficient fixed at 1, so if we
choose a prior distribution for the $\beta$ for the offset variable
having mean 1 and *very* high precision (so a very small variance) then we can
effectively force the $\beta$ to be 1 (or very, very close to 1), thus
approximating an offset term. Recall that functions in `MCMCpack` allow us to
set priors on our $\beta$'s individually via arguments `b0` and `B0`; we can
also use `beta.start` to set a starting value of 1 for the offset $\beta$.

## Exercises

* Perform an exploratory assessment of the emergency room complaints data set,
particularly how the response variable `complaints` varies with the proposed
explanatory variables relative to the number of visits. To do this, create
another variable which is the ratio of `complaints` to `visits`.

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Compute the ratio
    esdcomp$ratio <- esdcomp$complaints / esdcomp$visits
    # Plot the link with revenue
    plot(esdcomp$revenue,esdcomp$ratio)
    # Use boxplots against residency and gender
    boxplot(esdcomp$ratio ~ esdcomp$residency)
    boxplot(esdcomp$ratio ~ esdcomp$gender)
    ```
    
    </details>

* Fit a Bayesian model using `MCMCpoisson` using the `complaints` variable as
Poisson response and the others as covariates, and remembering the advice about
offsets above. Examine the output; does the model fit well, and is there any
evidence that any of the explanatory variables are associated with the rate of
complaints?

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Fit model
    esdcomp$log.visits <- log(esdcomp$visits)
    results2 <- MCMCpoisson(formula = complaints ~ log.visits + residency + gender + revenue,
                            data = esdcomp,
                            burnin = 5000, mcmc = 10000, thin=10,
                            beta.start = c(NA,1,NA,NA,NA), # uses maximum likelihood estimates as starting values when NA
                            b0 = c(0,1,0,0,0), # offset beta - mean 1 
                            B0 = c(0.0001,1000000,0.0001,0.0001,0.0001), # offset precision very high
                            verbose=1000)
    # Summarise output
    summary(results2)
    ```
    
    </details>


* Produce plots of the MCMC sample traces and the estimated posterior
distributions for the model parameters. Does it seem like convergence has been
achieved?

    <details><summary>Solution</summary>
    
    ```{r fig = TRUE, fig.width = 7, fig.height = 9}
    # Traces can be obtained separately
    par(mfrow =c(3, 2))
    traceplot(results2)
    ```

    ```{r fig = TRUE, fig.width = 7, fig.height = 7}
    # And the density plots
    par(mfrow =c(3, 2))
    densplot(results2)
    ```
    
    </details>

* Fit a non-Bayesian model using `glm()` for comparison. How do the model fits
compare?
    <details><summary>Solution</summary>
    
    ```{r fig = TRUE}
    # Fit model - note similarity with MCMCpack syntax
    esdcomp$log.visits <- log(esdcomp$visits)
    glm.output <- glm(formula = complaints ~ offset(log.visits) + residency + gender + revenue,
      data = esdcomp,
      family = "poisson")
    # Summarise output
    summary(glm.output)
    # Perform ANOVA on each variable in turn
    drop1(glm.output, test = "Chisq")
    ```

    </details>
